import os from 'os';
// @ts-ignore
import { Database, open } from 'sqlite';
import sqlite3 from 'sqlite3';
import { ConnectionStore } from '../store/ConnectionStore';
import { Engine } from '../store/Engine';
import { Register } from '../store/Register';
import uuid = require('uuid');
import ow from 'ow';

declare global {
  interface EngineNames {
    'SQLite': typeof SQLiteEngine;
  }
}

export class SQLiteEngine implements Engine {
  sqlite: Promise<Database>;
  table: string;

  constructor(option: any = {}) {
    const filename: string = option.filename || `${os.tmpdir()}/db.sqlite`;
    this.table = option.table || 'sessions';
    this.sqlite = open({ filename, driver: sqlite3.cached.Database })
      .then(async (db: Database) => {
        await db.run(`CREATE TABLE IF NOT EXISTS ${this.table} (
          id INT PRIMARY KEY,
          userId TEXT,
          scope TEXT,
          sessionId TEXT UNIQUE,
          meta TEXT,
          clientId TEXT,
          mode TEXT,
          refreshAt INTEGER,
          createdAt INTEGER
        );`);

        return db;
      });
  }

  async deleteById(sessionId: string): Promise<boolean> {
    const db = await this.sqlite;

    await db.run(`DELETE FROM ${this.table} WHERE sessionId = $sessionId`, {
      $sessionId: sessionId,
    });

    return true;
  }

  async deleteByUserId(userId: string): Promise<boolean> {
    const db = await this.sqlite;

    await db.run(`DELETE FROM ${this.table} WHERE userId = $userId`, {
      $userId: userId,
    });

    return true;
  }

  async deleteByIds(sessionIds: string[]): Promise<boolean> {
    const results = await Promise.all(sessionIds.map(
      sessionId => this.deleteById(sessionId),
    ));

    return results.every(result => result);
  }

  async update(register: Register, sets: any): Promise<Register> {
    if (!register.sessionId) return register;

    const db = await this.sqlite;

    ow(sets.refreshAt, 'sets.refreshAt', ow.number);

    await db.run(
      `UPDATE ${this.table}
      SET refreshAt = $refreshAt
      WHERE sessionId = $sessionId`,
      {
        $refreshAt: sets.refreshAt,
        $sessionId: register.sessionId,
      },
    );

    return this.findById(register.sessionId);
  }

  async findById(sessionId: string): Promise<Register> {
    const db = await this.sqlite;

    const result = await db.get<Register>(
      `SELECT * FROM ${this.table} WHERE sessionId = $sessionId;`,
      { $sessionId: sessionId },
    );

    if (!result) {
      throw new Error('Register was not created');
    }

    const { meta, ...res } = result;

    return {
      ...res,
      meta: JSON.parse(meta as unknown as string),
    };
  }

  async findByUserId(userId: string): Promise<Register[]> {
    const db = await this.sqlite;

    const results: Register[] = await db.all<Register>(
      `SELECT * FROM ${this.table} WHERE userId = $userId;`,
      { $userId: userId },
    );

    return results.map((result) => {
      const { meta, ...res } = result;
      return {
        ...res,
        meta: meta ? JSON.parse(meta) : undefined,
      };
    });
  }

  async create(sessionRegister: Register): Promise<Register> {
    const db = await this.sqlite;

    const sessionId = uuid();

    await db.run(
      `INSERT INTO ${this.table}
      VALUES (
        $id,
        $sessionId,
        $userId,
        $createdAt,
        $scope,
        $data,
        $refreshAt
      );`,
      {
        $id: Date.now(),
        $sessionId: sessionId,
        $userId: sessionRegister.userId,
        $createdAt: Date.now(),
        $scope: sessionRegister.scope,
        $data: JSON.stringify(sessionRegister.data),
        $refreshAt: Date.now(),
      },
    );

    const register = await this.findById(sessionId);

    if (!register) {
      throw new Error('Register was not created');
    }

    return register;
  }
}

// Default engines
ConnectionStore.add('SQLite', SQLiteEngine);
